CREATE TABLE people(
	person_id	INTEGER GENERATED BY DEFAULT AS identity (start with 2000000) PRIMARY KEY,
	name		TEXT NOT NULL UNIQUE
);

CREATE TABLE movies(
	movie_id			INTEGER GENERATED BY DEFAULT AS identity (start with 5000) PRIMARY KEY,
	title 				TEXT NOT NULL,
	release_date		DATE, 
	runtime				INTEGER,
	description			TEXT
);

CREATE TABLE genres(
	movie_id		INTEGER references movies(movie_id) on delete cascade,
	genre			TEXT not null
); 

create table countries(
	movie_id		INTEGER references movies(movie_id) on delete cascade,
	country			TEXT not null
);

CREATE TABLE people_movies(
	movie_id		INTEGER REFERENCES movies(movie_id) on delete cascade,
	person_id		INTEGER REFERENCES people(person_id) on delete cascade,
	role			TEXT not NULL
);

create table users(
	user_id 	INTEGER GENERATED BY DEFAULT AS identity primary key,
	nick 		TEXT not null UNIQUE,
	password 	TEXT not null
);

create table actions(
	action_id 		INTEGER GENERATED BY DEFAULT AS identity primary key,
	movie_id 		INTEGER REFERENCES movies(movie_id) on delete set null,
	user_id			INTEGER REFERENCES users(user_id) on delete set null, 
	type 			TEXT CHECK(type in ('rate','list','watched'))
);

create table ratings(
	action_id		INTEGER references actions(action_id) on delete cascade,
	rating			INTEGER,
	review 			TEXT
);

create table watchlists(
	action_id		INTEGER references actions(action_id) on delete cascade,
	list_name		TEXT
);





create or replace function movie_cast(t INTEGER) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select p.name
	from people p natural join people_movies pm natural join movies m
	where m.movie_id = t AND pm.role LIKE 'Actor';
END;
$$ language 'plpgsql';


create or replace function actor_movies(t TEXT) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select m.title
	from people p natural join people_movies pm natural join movies m
	where p.name ILIKE t AND pm.role LIKE 'Actor';
END;
$$ language 'plpgsql';
	

create or replace function movie_director(t INTEGER) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select p.name
	from people p natural join people_movies pm natural join movies m
	where m.movie_id = t AND pm.role LIKE 'Director';
END;
$$ language 'plpgsql';


create or replace function director_movies(t TEXT) returns TABLE(m_id INTEGER, m_title TEXT, m_year DATE) as $$
BEGIN
	RETURN QUERY
	select m.movie_id, m.title, m.release_date
	from people p natural join people_movies pm natural join movies m
	where p.name ILIKE t AND pm.role LIKE 'Director';
END;
$$ language 'plpgsql';


create or replace function movies_from(t TEXT) returns TABLE(m_id INTEGER, m_title TEXT, m_year DATE) as $$
BEGIN
	RETURN QUERY
	select m.movie_id, m.title, m.release_date
	from countries c natural join movies m
	where c.country ILIKE t;
END;
$$ language 'plpgsql';


create or replace function genre_movies(t TEXT) returns TABLE(m_id INTEGER, m_title TEXT, m_year DATE) as $$
BEGIN
	RETURN QUERY
	select m.movie_id, m.title, m.release_date
	from genres g natural join movies m
	where g.genre ILIKE t;
END;
$$ language 'plpgsql';


create or replace function add_pm(
	movie_id INTEGER, 
	actor TEXT, 
	role TEXT
) returns VOID AS $$
DECLARE
	p_id INTEGER;
BEGIN
	INSERT INTO people (name) VALUES (actor) ON CONFLICT (name) DO NOTHING;
	SELECT person_id INTO p_id FROM people WHERE name = actor;
	INSERT INTO people_movies VALUES (movie_id, p_id, role);
END;
$$ language 'plpgsql';

create or replace function add_movie(
	title TEXT, release_date DATE, 
	runtime INTEGER, description TEXT, 
	actors TEXT[], directors TEXT[],
	country_l TEXT[], genre_l TEXT[]
	) returns VOID as $$
DECLARE
	m_id INTEGER;
	director TEXT;
	actor TEXT;
	country TEXT;
	genre TEXT;
BEGIN
	INSERT INTO movies (title,release_date,runtime,description) VALUES (title,release_date,runtime,description)
	RETURNING movie_id INTO m_id;
	FOREACH director IN ARRAY directors LOOP
		PERFORM add_pm(m_id, director, 'Director');
	END LOOP;
	FOREACH actor IN ARRAY actors LOOP
		PERFORM add_pm(m_id, actor, 'Actor');
	END LOOP;
	FOREACH country IN ARRAY country_l LOOP
		INSERT INTO countries VALUES (m_id, country);
	END LOOP;
	FOREACH genre IN ARRAY genre_l LOOP
		INSERT INTO genres VALUES (m_id, genre);
	END LOOP;
END;
$$ language 'plpgsql';

create view top_10 as
	select m.title, m.release_date, m.runtime, r.average_rating
	from movies m 
	join  (select movie_id, avg(rating)::DECIMAL(4,2) as average_rating 
			from actions natural join ratings
			group by movie_id) r using (movie_id)
	order by r.average_rating desc
	limit 10;

create or replace function rate(
	m_id INTEGER, u_id INTEGER, 
	rating_v DECIMAL, review_v TEXT
	) returns VOID AS $$
DECLARE
	a_id INTEGER;
BEGIN
	INSERT INTO actions (movie_id, user_id, type) VALUES (m_id, u_id,'rate')
	RETURNING action_id INTO a_id;
	INSERT INTO ratings(action_id,rating,review) VALUES(a_id,rating_v,review_v);
END;
$$ language 'plpgsql';


create or replace function add_to_list(
	m_id INTEGER, u_id INTEGER, 
	l_name TEXT
	) returns VOID AS $$
DECLARE
	a_id INTEGER;
BEGIN
	INSERT INTO actions (movie_id, user_id, type) VALUES (m_id, u_id,'list')
	RETURNING action_id INTO a_id;
	INSERT INTO watchlists(action_id,list_name) VALUES(a_id,l_name);
END;
$$ language 'plpgsql';


create or replace function change_password(u_id INTEGER, new_password TEXT) returns TEXT as $$
BEGIN
	update users set password = new_password where user_id = u_id;
	RETURN 'Hasło zostało zmienione.';
END;
$$ language 'plpgsql';


create or replace function delete_from_list(u_id INTEGER, m_id INTEGER, l_name TEXT) returns TEXT as $$
begin
	delete from actions
	where user_id = u_id and movie_id = m_id 
	and action_id in (SELECT action_id FROM watchlists WHERE list_name = l_name);
	return 'Usunięto film z listy.';
end;
$$ language 'plpgsql';

create or replace function delete_rating(u_id INTEGER, m_id INTEGER) returns TEXT as $$
begin
	delete from actions
	where user_id = u_id and movie_id = m_id 
	and action_id in (SELECT action_id FROM ratings);
	return 'Usunięto ocenę filmu';
end;
$$ language 'plpgsql';


create or replace function delete_watched(u_id INTEGER, m_id INTEGER) returns VOID as $$
begin
	delete from actions
	where user_id = u_id and movie_id = m_id and type = 'watched';
end;
$$ language 'plpgsql';


