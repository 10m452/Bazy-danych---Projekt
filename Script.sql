CREATE TABLE people(
	person_id	INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	name		TEXT NOT NULL UNIQUE
);

CREATE TABLE genres(
	movie_id		INTEGER references movies(movie_id) on delete cascade,
	genre			TEXT not null
); 

create table countries(
	movie_id		INTEGER references movies(movie_id) on delete cascade,
	country			TEXT not null
);

CREATE TABLE movies(
	movie_id			INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	title 				TEXT NOT NULL,
	release_date		DATE, 
	time				INTEGER,
	description			TEXT
);

CREATE TABLE people_movies(
	movie_id		INTEGER REFERENCES movies(movie_id) on delete cascade,
	person_id		INTEGER REFERENCES people(person_id) on delete cascade,
	position		TEXT not NULL
);

create table users(
	user_id 	INTEGER GENERATED BY DEFAULT AS identity primary key,
	nick 		TEXT not null UNIQUE,
	password 	TEXT not null
);

create table actions(
	action_id 		INTEGER GENERATED BY DEFAULT AS identity primary key,
	movie_id 		INTEGER REFERENCES movies(movie_id) on delete set null,
	user_id			INTEGER REFERENCES users(user_id) on delete set null, 
	type 			TEXT CHECK(type in ('rate','list','watched'))
);

create table ratings(
	action_id		INTEGER references actions(action_id),
	rating			INTEGER,
	review 			TEXT
);

create table watchlists(
	action_id		INTEGER references actions(action_id),
	list_name		TEXT
);

create or replace function movie_cast(t INTEGER) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select p.name
	from people p natural join people_movies pm natural join movies m
	where m.movie_id = t AND pm.position LIKE 'Actor';
END;
$$ language 'plpgsql';


create or replace function actor_movies(t TEXT) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select m.title
	from people p natural join people_movies pm natural join movies m
	where t ILIKE p.name AND pm.position LIKE 'Actor';
END;
$$ language 'plpgsql';
	

create or replace function movie_director(t INTEGER) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select p.name
	from people p natural join people_movies pm natural join movies m
	where m.movie_id = t AND pm.position LIKE 'Director';
END;
$$ language 'plpgsql';


create or replace function director_movies(t TEXT) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select m.title
	from people p natural join people_movies pm natural join movies m
	where t ILIKE p.name AND pm.position LIKE 'Director';
END;
$$ language 'plpgsql';


create or replace function movies_from(t TEXT) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select m.title
	from countries c natural join movies m
	where c.country ILIKE t;
END;
$$ language 'plpgsql';


create or replace function genre_movies(t TEXT) returns setof TEXT as $$
BEGIN
	RETURN QUERY
	select m.title
	from genres g natural join movies m
	where g.genre ILIKE t;
END;
$$ language 'plpgsql';


create or replace function add_pm(movie_id INTEGER, actor TEXT, position TEXT) returns VOID AS $$
DECLARE
	p_id INTEGER;
BEGIN
	INSERT INTO people VALUES (actor) ON CONFLICT (name) DO NOTHING;
	SELECT person_id INTO p_id FROM people WHERE name = actor;
	INSERT INTO people_movies VALUES (p_id, movie_id, position);
END;
$$ language 'plpgsql';

create or replace function add_movie(title TEXT, 
create or replace function get_id_movie RETURNS TRIGGER AS $$
BEGIN
	
END;
$$ language 'plpgsql';

DROP TRIGGER get_id_movie ON movies CASCADE;
CREATE TRIGGER get_id_movie AFTER INSERT ON movies
		

